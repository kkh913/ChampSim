#include "cache.h"

#define NOFFSETS 16
#define NSUBOFFSETS 4
#define NSETS 4
#define DEGREE 4
#define NLAYERS 4
#define NENTRIES 64
#define INDEXSIZE 6
#define TAGSIZE 6

#define MAXSCORE 31
#define MAXROUND 127

#define TRUNCATE(x, nbits) (((x) & ((1 << (nbits)) - 1)))
#define SAMEPAGE(lineaddr1, lineaddr2) ((((lineaddr1) ^ (lineaddr2)) >> 6) == 0)

uint16_t accessCount;

const int offsets[NOFFSETS] = {1,  2,  3,  4,  5,  6,  8,  9,
                               10, 12, 15, 16, 18, 20, 24, 32};

struct Entry {
  uint8_t tag;
  uint8_t index;
};

struct Layer {
  int offset[NSUBOFFSETS];
  int score[NSUBOFFSETS];
  bool inserted[NSUBOFFSETS];
  Entry table[NLAYERS][NENTRIES];

  int increase;

  // For statistics
  uint64_t real_addr[NLAYERS][NENTRIES];
  uint64_t life_time[NLAYERS][NENTRIES];
};

Layer layers[NSETS];

int offset_list[DEGREE];

int stack[DEGREE];

int stack_pointer;

uint64_t totalUsedOffset[NOFFSETS];
uint64_t totalLayerHits;
uint64_t totalFalsePositive;
uint64_t totalLifeTime;
uint64_t sampledTags;

void clearOffsetList() {
  for (int i = 0; i < DEGREE; ++i) {
    offset_list[i] = 0;
  }
  offset_list[0] = 1;
}

void clearLayerScore() {
  for (int i = 0; i < NSETS; ++i) {
    for (int j = 0; j < NSUBOFFSETS; ++j) {
      layers[i].score[j] = 0;
      layers[i].inserted[j] = false;
    }
  }
}

void clearStack() {
  for (int i = 0; i < DEGREE; ++i) {
    stack[i] = 0;
  }
  stack_pointer = 0;
  accessCount = 0;

  clearLayerScore();
}

void copyStack() {
  for (int i = 0; i < DEGREE; ++i) {
    offset_list[i] = stack[i];
  }
}

void increaseLifeTime(int layer, int index) {
  for (int i = 0; i < NSETS; ++i) {
    for (int j = 0; j < NLAYERS; ++j) {
      for (int k = 0; k < NENTRIES; ++k) {
        if (layers[i].table[j][k].tag && j != layer && k != index) {
          ++layers[i].life_time[j][k];
        }
      }
    }
  }
}

void virtualPrefetch(uint64_t blkAddr, int num) {

  for (int i = 0; i < NSUBOFFSETS; ++i) {

    uint64_t pf = blkAddr + layers[num].offset[i];
    int index = TRUNCATE(pf, INDEXSIZE);
    int layer = rand() % NLAYERS;
    uint8_t tag = TRUNCATE(pf >> INDEXSIZE, TAGSIZE);

    if (layers[num].table[layer][index].tag != tag) { // replacement event
      ++sampledTags;
      totalLifeTime += layers[num].life_time[layer][index];
      layers[num].life_time[layer][index] = 0;
      increaseLifeTime(layer, index);
    } else {
      increaseLifeTime(-1, -1);
    }

    layers[num].table[layer][index].tag = tag;
    layers[num].table[layer][index].index = i;
    layers[num].real_addr[layer][index] = pf;
  }
}

void findTag(uint64_t blkAddr) {
  int index = TRUNCATE(blkAddr, INDEXSIZE);
  uint8_t tag = TRUNCATE(blkAddr >> INDEXSIZE, TAGSIZE);

  for (int i = 0; i < NSETS; ++i) {
    for (int layer = 0; layer < NLAYERS; ++layer) {
      if (layers[i].table[layer][index].tag == tag) { //  find tag -> score up.
        ++totalLayerHits;
        if (layers[i].real_addr[layer][index] != blkAddr) {
          ++totalFalsePositive;
        }
        int offset_index = layers[i].table[layer][index].index;
        layers[i].score[offset_index] += layers[i].increase;
      }
    }

    virtualPrefetch(blkAddr, i);

    for (int j = 0; j < NSUBOFFSETS; ++j) {
      if (layers[i].score[j] > MAXSCORE && layers[i].inserted[j] == false) {
        stack[stack_pointer] = layers[i].offset[j];
        layers[i].inserted[j] = true;
        ++stack_pointer;
      }

      if (stack_pointer > DEGREE) {
        copyStack();
        clearStack();
      }
    }
  }
}

void recordOffsetStats(int offset) {
  for (int i = 0; i < NOFFSETS; ++i) {
    if (offsets[i] == offset) {
      ++totalUsedOffset[i];
      break;
    }
  }
}

void CACHE::l2c_prefetcher_initialize() {
  cout << "L2C Layer Preftcher" << endl;

  for (int i = 0; i < NSETS; ++i) {
    for (int sub = 0; sub < NSUBOFFSETS; ++sub) {
      layers[i].score[sub] = 0;
      layers[i].inserted[sub] = false;
    }
    for (int layer = 0; layer < NLAYERS; ++layer) {
      for (int entry = 0; entry < NENTRIES; ++entry) {
        layers[i].table[layer][entry].tag = 0;
        layers[i].table[layer][entry].index = 0;
        layers[i].real_addr[layer][entry] = 0;
        layers[i].life_time[layer][entry] = 0;
      }
    }
  }

  //  set 0
  layers[0].offset[0] = 1;
  layers[0].offset[1] = 2;
  layers[0].offset[2] = 3;
  layers[0].offset[3] = 4;
  layers[0].increase = 8;

  //  set 1
  layers[1].offset[0] = 5;
  layers[1].offset[1] = 6;
  layers[1].offset[2] = 8;
  layers[1].offset[3] = 9;
  layers[1].increase = 4;

  //  set 2
  layers[2].offset[0] = 10;
  layers[2].offset[1] = 12;
  layers[2].offset[2] = 15;
  layers[2].offset[3] = 16;
  layers[2].increase = 2;

  //  set 2
  layers[3].offset[0] = 18;
  layers[3].offset[1] = 20;
  layers[3].offset[2] = 24;
  layers[3].offset[3] = 32;
  layers[3].increase = 1;

  accessCount = 0;

  clearOffsetList();
  clearStack();
}

void CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip,
                                   uint8_t cache_hit, uint8_t type) {
  uint64_t cl_address = addr >> LOG2_BLOCK_SIZE;

  ++accessCount;

  findTag(cl_address);

  if (accessCount > MAXROUND) {
    copyStack();
    clearStack();
  }

  for (int i = 0; i < DEGREE; ++i) {
    if (offset_list[i] != 0) {
      if (SAMEPAGE(cl_address, cl_address + offset_list[i])) {
        recordOffsetStats(offset_list[i]);
        uint64_t pf_addr = (cl_address + offset_list[i]) << LOG2_BLOCK_SIZE;
        if (MSHR.occupancy < 8) {
          prefetch_line(ip, addr, pf_addr, FILL_L2);
        } else {
          prefetch_line(ip, addr, pf_addr, FILL_LLC);
        }
      }
    } else {
      break;
    }
  }
}

void CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way,
                                      uint8_t prefetch, uint64_t evicted_addr) {
}

void CACHE::l2c_prefetcher_final_stats() {
  cout << endl << "L2C Layer Prefetcher final stats" << endl;
  for (int i = 0; i < NOFFSETS; ++i) {
    cout << "CPU" << cpu << " Number of used offset " << offsets[i] << " : "
         << totalUsedOffset[i] << endl;
  }
  cout << "CPU" << cpu
       << " Total number of hits in layer sets : " << totalLayerHits << endl;
  cout << "CPU" << cpu
       << " Total number of false positive : " << totalFalsePositive << endl;
  cout << "CPU" << cpu << " Total of tag life : " << totalLifeTime << endl;
  cout << "CPU" << cpu << " Number of evicted tags : " << sampledTags << endl;
  cout << "CPU" << cpu
       << " Average of tag life : " << (double)totalLifeTime / sampledTags
       << endl;
}
