#include "cache.h"

#define NOFFSETS 7
#define DEGREE 7
#define NLAYERS 4
#define NENTRIES 64
#define INDEXSIZE 6
#define TAGSIZE 6

#define MAXSCORE 31
#define MAXROUND 127

#define TRUNCATE(x, nbits) (((x) & ((1 << (nbits)) - 1)))
#define SAMEPAGE(lineaddr1, lineaddr2) ((((lineaddr1) ^ (lineaddr2)) >> 6) == 0)

uint16_t accessCount[NUM_CPUS];

const int offsets[NOFFSETS] = {1, 2, 3, 4, 5, 6, 7};

struct Entry {
  uint8_t tag;
  bool valid;
};

struct Layer {
  Layer() : offset(0) {}

  int offset;
  int score;
  bool inserted;
  Entry table[NLAYERS][NENTRIES];

  // For statistics
  uint64_t real_addr[NLAYERS][NENTRIES];
  uint64_t life_time[NLAYERS][NENTRIES];
};

Layer layers[NUM_CPUS][NOFFSETS];

Entry filter[NUM_CPUS][NLAYERS][NENTRIES];

int offset_list[NUM_CPUS][DEGREE];

int stack[NUM_CPUS][DEGREE];

int stack_pointer[NUM_CPUS];

uint64_t totalUsedOffset[NUM_CPUS][NOFFSETS];
uint64_t totalLayerHits[NUM_CPUS];
uint64_t totalFalsePositive[NUM_CPUS];
uint64_t totalLifeTime[NUM_CPUS];
uint64_t sampledTags[NUM_CPUS];
uint64_t histoPrefetchDegree[NUM_CPUS][DEGREE + 1];
uint64_t totalFilteredPrefetches[NUM_CPUS];
uint64_t totalInsertedUseless[NUM_CPUS];
uint64_t totalRemovedUseful[NUM_CPUS];

void clearOffsetList(uint8_t cpu) {
  for (int i = 0; i < DEGREE; ++i) {
    offset_list[cpu][i] = 0;
  }
  offset_list[cpu][0] = 1;
}

void clearLayerScore(uint8_t cpu) {
  for (int i = 0; i < NOFFSETS; ++i) {
    layers[cpu][i].score = 0;
    layers[cpu][i].inserted = false;
  }
}

void clearStack(uint8_t cpu) {
  for (int i = 0; i < DEGREE; ++i) {
    stack[cpu][i] = 0;
  }
  stack_pointer[cpu] = 0;
  accessCount[cpu] = 0;

  clearLayerScore(cpu);
}

void copyStack(uint8_t cpu) {
  for (int i = 0; i < DEGREE; ++i) {
    offset_list[cpu][i] = stack[cpu][i];
  }
}

void increaseLifeTime(uint8_t cpu, int layer, int index) {
  for (int i = 0; i < NOFFSETS; ++i) {
    for (int j = 0; j < NLAYERS; ++j) {
      for (int k = 0; k < NENTRIES; ++k) {
        if (layers[cpu][i].table[j][k].valid && j != layer && k != index) {
          ++layers[cpu][i].life_time[j][k];
        }
      }
    }
  }
}

void virtualPrefetch(uint8_t cpu, uint64_t blkAddr, int num) {
  uint64_t pf = blkAddr + layers[cpu][num].offset;
  int index = TRUNCATE(pf, INDEXSIZE);
  int layer = rand() % NLAYERS;
  uint8_t tag = TRUNCATE(pf >> INDEXSIZE, TAGSIZE);

  if (layers[cpu][num].table[layer][index].tag != tag &&
      layers[cpu][num].table[layer][index].valid) {  // replacement event
    ++sampledTags[cpu];
    totalLifeTime[cpu] += layers[cpu][num].life_time[layer][index];
    layers[cpu][num].life_time[layer][index] = 0;
    increaseLifeTime(cpu, layer, index);
  } else {
    increaseLifeTime(cpu, -1, -1);
  }

  layers[cpu][num].table[layer][index].tag = tag;
  layers[cpu][num].table[layer][index].valid = true;
  layers[cpu][num].real_addr[layer][index] = pf;
}

void findTag(uint8_t cpu, uint64_t blkAddr) {
  int index = TRUNCATE(blkAddr, INDEXSIZE);
  uint8_t tag = TRUNCATE(blkAddr >> INDEXSIZE, TAGSIZE);

  for (int i = 0; i < NOFFSETS; ++i) {
    for (int layer = 0; layer < NLAYERS; ++layer) {
      if (layers[cpu][i].table[layer][index].tag == tag &&
          layers[cpu][i].table[layer][index].valid) {  //  find tag -> score up.
        ++totalLayerHits[cpu];
        if (layers[cpu][i].real_addr[layer][index] != blkAddr) {
          ++totalFalsePositive[cpu];
        }
        ++layers[cpu][i].score;
      }
    }

    virtualPrefetch(cpu, blkAddr, i);

    if (layers[cpu][i].score > MAXSCORE && layers[cpu][i].inserted == false) {
      stack[cpu][stack_pointer[cpu]] = layers[cpu][i].offset;
      layers[cpu][i].inserted = true;
      ++stack_pointer[cpu];
    }

    if (stack_pointer[cpu] > DEGREE) {
      copyStack(cpu);
      clearStack(cpu);
    }
  }
}

bool issue_prefetch(uint8_t cpu, uint64_t blkAddr) {
  bool ret = true;
  int index = TRUNCATE(blkAddr, INDEXSIZE);
  uint8_t tag = TRUNCATE(blkAddr >> INDEXSIZE, TAGSIZE);

  for (int layer = 0; layer < NLAYERS; ++layer) {
    if (filter[cpu][layer][index].tag == tag &&
        filter[cpu][layer][index].valid) {
      ret = false;
    }
  }

  return ret;
}

void recordOffsetStats(uint8_t cpu, int offset) {
  for (int i = 0; i < NOFFSETS; ++i) {
    if (offsets[i] == offset) {
      ++totalUsedOffset[cpu][i];
      break;
    }
  }
}

void recordPrefetchDegree(uint8_t cpu, int degree) {
  ++histoPrefetchDegree[cpu][degree];
}

void CACHE::l2c_prefetcher_initialize() {
  cout << "L2C Layer Prefetcher" << endl;

  for (int i = 0; i < NOFFSETS; ++i) {
    layers[cpu][i].offset = offsets[i];
    layers[cpu][i].score = 0;
    layers[cpu][i].inserted = false;
    for (int j = 0; j < NLAYERS; ++j) {
      for (int k = 0; k < NENTRIES; ++k) {
        layers[cpu][i].table[j][k].tag = 0;
        layers[cpu][i].table[j][k].valid = false;
        layers[cpu][i].real_addr[j][k] = 0;
        layers[cpu][i].life_time[j][k] = 0;
      }
    }
  }

  for (int j = 0; j < NLAYERS; ++j) {
    for (int k = 0; k < NENTRIES; ++k) {
      filter[cpu][j][k].tag = 0;
      filter[cpu][j][k].valid = false;
    }
  }

  accessCount[cpu] = 0;

  clearOffsetList(cpu);
  clearStack(cpu);
}

void CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip,
                                   uint8_t cache_hit, uint8_t type) {
  uint64_t cl_address = addr >> LOG2_BLOCK_SIZE;

  ++accessCount[cpu];

  findTag(cpu, cl_address);

  if (accessCount[cpu] > MAXROUND) {
    copyStack(cpu);
    clearStack(cpu);
  }

  int count_prefetch = 0;

  for (int i = 0; i < DEGREE; ++i) {
    if (offset_list[cpu][i] != 0) {
      if (SAMEPAGE(cl_address, cl_address + offset_list[cpu][i])) {
        recordOffsetStats(cpu, offset_list[cpu][i]);

        uint64_t pf_blkAddr = cl_address + offset_list[cpu][i];

        if (issue_prefetch(cpu, pf_blkAddr)) {
          uint64_t pf_addr = pf_blkAddr << LOG2_BLOCK_SIZE;

          if (MSHR.occupancy < 8) {
            if (prefetch_line(ip, addr, pf_addr, FILL_L2)) {
              ++count_prefetch;
            }
          } else {
            if (prefetch_line(ip, addr, pf_addr, FILL_LLC)) {
              ++count_prefetch;
            }
          }

          if (count_prefetch) {
            int index = TRUNCATE(pf_blkAddr, INDEXSIZE);
            uint8_t tag = TRUNCATE(pf_blkAddr >> INDEXSIZE, TAGSIZE);
            int layer = rand() % NLAYERS;
            filter[cpu][layer][index].tag = tag;
            filter[cpu][layer][index].valid = true;
          }

        } else {
          ++totalFilteredPrefetches[cpu];
        }
      }
    }
  }

  recordPrefetchDegree(cpu, count_prefetch);
}

void CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way,
                                      uint8_t prefetch, uint64_t evicted_addr) {
  // set is not the set of cache. this is a prefetch bit. if it is 1,
  // evicted_addr is the address of useless prefetch
  uint64_t blkAddr = evicted_addr >> LOG2_BLOCK_SIZE;

  int index = TRUNCATE(blkAddr, INDEXSIZE);
  uint8_t tag = TRUNCATE(blkAddr >> INDEXSIZE, TAGSIZE);

  bool exist = false;
  int i = 0;

  for (int layer = 0; layer < NLAYERS; ++layer) {
    if (filter[cpu][layer][index].tag == tag &&
        filter[cpu][layer][index].valid) {
      exist = true;
      i = layer;
      break;
    }
  }

  if (set) {  //  for useless prefetch block... need to filter it
    if (!exist) {
      int num = rand() % NLAYERS;
      filter[cpu][num][index].tag = tag;
      filter[cpu][num][index].valid = true;
      ++totalInsertedUseless[cpu];
    }
  } else {  //  for useful prefetch block... need to remove it from filter
    if (exist) {
      filter[cpu][i][index].tag = 0;
      filter[cpu][i][index].valid = false;
      ++totalRemovedUseful[cpu];
    }
  }
}

void CACHE::l2c_prefetcher_final_stats() {
  cout << endl << "L2C Layer Prefetcher final stats" << endl;
  for (int i = 0; i < NOFFSETS; ++i) {
    cout << "CPU" << cpu << " Number of used offset " << offsets[i] << " : "
         << totalUsedOffset[cpu][i] << endl;
  }
  cout << "CPU" << cpu
       << " Total number of hits in layer sets : " << totalLayerHits[cpu]
       << endl;
  cout << "CPU" << cpu
       << " Total number of false positive : " << totalFalsePositive[cpu]
       << endl;
  cout << "CPU" << cpu << " Total of tag life : " << totalLifeTime[cpu] << endl;
  cout << "CPU" << cpu << " Number of evicted tags : " << sampledTags[cpu]
       << endl;
  cout << "CPU" << cpu << " Average of tag life : "
       << (double)totalLifeTime[cpu] / sampledTags[cpu] << endl;
  for (int i = 0; i < DEGREE + 1; ++i) {
    cout << "CPU" << cpu << " Degree " << i << ": "
         << histoPrefetchDegree[cpu][i] << endl;
  }
  cout << "CPU" << cpu
       << " Number of filtered prefetches : " << totalFilteredPrefetches[cpu]
       << endl;
  cout << "CPU" << cpu
       << " Number of useless prefetches inserted into filter : "
       << totalInsertedUseless[cpu] << endl;
  cout << "CPU" << cpu << " Number of useful prefetches removed from filter : "
       << totalRemovedUseful[cpu] << endl;
}
